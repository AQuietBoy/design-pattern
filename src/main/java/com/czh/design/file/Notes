
		                                              Design Patterns （设计模式）

创建型模式：提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象;

	1、工厂模式：

	    意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行;

		优点：

		    1、一个调用者想创建一个对象，只要知道其名称就可以了;

	    	2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以;

			3、屏蔽产品的具体实现，调用者只关心产品的接口;

		缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事;

	2、抽象工厂模式：

	    意图：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类;

		优点：当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象;

		缺点：产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码;

	3、单例模式：

	    意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点;

		实现方式：

		    1、懒汉式，线程不安全，Lazy初始化;

			2、懒汉式，线程安全，Lazy初始化;

			3、饿汉式，线程安全，Lazy初始化（否）;

			4、双检索/双重校验锁，线程安全，Lazy初始化;

			5、登记式/静态内部类，线程安全，Lazy初始化;

			6、枚举，线程安全，Lazy初始化（否）;

		优点：

		    1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）;

			2、避免对资源的多重占用（比如写文件操作）;

	    缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化;

	4、建造者模式：

	    意图：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示;

		优点：

		    1、建造者独立，易扩展;

			2、便于控制细节风险;

	    缺点：

		    1、产品必须有共同点，范围有限制;

			2、如内部变化复杂，会有很多的建造类;

	5、原型模式：

	    意图：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象;

	    优点：

		     1、性能提高;

			 2、逃避构造函数的约束;

		缺点：

		    1、配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候;

			2、必须实现 Cloneable 接口。

结构型模式：这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式;

    1、适配器模式：

	    意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作;

		优点：

		     1、可以让任何两个没有关联的类一起运行;

			 2、提高了类的复用;

			 3、增加了类的透明度;

			 4、灵活性好;

		缺点：

		    1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构;

			2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

	2、桥接模式：

	    意图：将抽象部分与实现部分分离，使它们都可以独立的变化;

		优点：

		    1、抽象和实现的分离。

			2、优秀的扩展能力。

			3、实现细节对客户透明;

		缺点：桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程;

	3、过滤器模式：

	    意图：这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来;

	4、组合模式：

	    意图：将对象组合成树形结构以表示"部分-整体"的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性;

		优点：

		    1、高层模块调用简单;

			2、节点自由增加;

		缺点：在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则;

	5、装饰器模式：

	    意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活;

		优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能;

		缺点：多层装饰比较复杂;

	6、外观模式：

	    意图：为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用;

		优点：

		    1、减少系统相互依赖;

			2、提高灵活性;

			3、提高了安全性;

		缺点：不符合开闭原则，如果要改东西很麻烦，继承重写都不合适;

	7、享元模式：

	    意图：运用共享技术有效地支持大量细粒度的对象;

		优点：大大减少对象的创建，降低系统的内存，使效率提高;

		缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱;

	8、代理模式：

	    意图：为其他对象提供一种代理以控制对这个对象的访问;

		优点：

		    1、职责清晰;

			2、高扩展性;

			3、智能化;

	    缺点：

		    1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢;

			2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂;

行为型模式：这些设计模式特别关注对象之间的通信;

    1、责任链模式：

	    意图：避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止;

		优点：

		    1、降低耦合度。它将请求的发送者和接收者解耦;

			2、简化了对象。使得对象不需要知道链的结构;

			3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任;

			4、增加新的请求处理类很方便;

		缺点：

		    1、不能保证请求一定被接收;

			2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用;

			3、可能不容易观察运行时的特征，有碍于除错;

	2、命令模式：

	    意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化;

		优点：

		     1、降低了系统耦合度;

			 2、新的命令可以很容易添加到系统中去;

	    缺点：使用命令模式可能会导致某些系统有过多的具体命令类;

	3、解释器模式：

	    意图：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子;

		优点：

		    1、可扩展性比较好，灵活;

			2、增加了新的解释表达式的方式;

			3、易于实现简单文法;

		缺点：

		    1、可利用场景比较少;

			2、对于复杂的文法比较难维护;

			3、解释器模式会引起类膨胀;

			4、解释器模式采用递归调用方法;

	4、迭代器模式：

	    意图：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示;

		优点：

		    1、它支持以不同的方式遍历一个聚合对象;

			2、迭代器简化了聚合类;

			3、在同一个聚合上可以有多个遍历;

			4、在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码;

		缺点：由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性;

	5、中介者模式：

	    意图：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互;

		优点：

		    1、降低了类的复杂度，将一对多转化成了一对一;

			2、各个类之间的解耦;

			3、符合迪米特原则;

		缺点：中介者会庞大，变得复杂难以维护;

	6、备忘录模式：

	    意图：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态;

		优点：

		    1、给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态;

			2、实现了信息的封装，使得用户不需要关心状态的保存细节;

		缺点：消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存;

	7、观察者模式：

	    意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新;

		优点：

		    1、观察者和被观察者是抽象耦合的;

			2、建立一套触发机制;

		缺点：

		    1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间;

			2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃;

			3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化;

	8、状态模式：

	    意图：允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类;

		优点：

		     1、封装了转换规则;

			 2、枚举可能的状态，在枚举状态之前需要确定状态种类;

			 3、将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为;

			 4、允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块;

			 5、可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数;

	    缺点：

		    1、状态模式的使用必然会增加系统类和对象的个数;

			2、状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱;

			3、状态模式对"开闭原则"的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态，而且修改某个状态类的行为也需修改对应类的源代码;

	9、空对象模式：

	10、策略模式：

	11、模板模式：

	12、访问者模式：

J2EE模式：这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的;

    1、MVC模式：

	2、业务代表模式：

	3、组合实体模式：

	4、数据访问对象模式：

	5、前端控制器模式：

	6、拦截过滤器模式：

	7、服务定位器模式：

	8：传输对象模式：





